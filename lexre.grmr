export = re
import = lexreparser

punctuator:
    '*' | '|' | '.' | '^' | '$' | '?' | '(' | ')' | '[' | ']' | '-' | '=' | '!' | '<' | ',' | '+' | '}' | '{'

// characters are any unescaped normal printing characters. cannot be "." else sequence will capture everything

newline:
    "\n"

re_escape:
    "\\\\"

any_byte:
    "."

token:
    punctuator | any_byte

// characters that must be escaped: \^$.[|()*+?{
non_escape:
    "[^\\\\^$.\\[|()*+?{]"
    //"[^\\\\^$.\\[|()*?]" // not escaping '{' and '+' because they are handled by the preprocessor

character_class:
    "[^\\\\\\-\\]\\^]"

range:
    // note that this is basically: "class_char", but I don't want the build action on it
    (escaped_character | character_class), '-', (escaped_character | character_class)

char_class(re_build_char_class):
    '[', '^'?, (range | escaped_character | character_class)+, ']'

// build symbol should just pass the char_class or build character from single_car, which may be recursive
symbol(re_build_symbol):
    '^' | '$' | escaped_character | non_escape

non_rparen:
    "[^)]"

simple_escape:
    re_escape, any_byte

hex_digit:
    "[0-9a-fA-F]"

unicode4:
    'u'

unicode8:
    'U'

unicode_seq:
    re_escape, (unicode4, hex_digit{4} | unicode8, hex_digit{8})

escaped_character:
    unicode_seq | simple_escape

lookahead(re_build_lookaround):
    '(', '?', ('=' | '!'), choice, ')'

lookbehind(re_build_lookaround):
    '(', '?', '<', ('=' | '!'), (escaped_character | non_rparen)+, ')'

element(re_build_element):
    lookbehind | lookahead | '(', choice, ')' | char_class | symbol

digit:
    "[0-9]"

repeated(re_build_repeated):
    element, ('+' | '*' | '?' | '{', digit*, ','?, digit*, '}')?

sequence(re_build_sequence):
    repeated+

choice(re_build_choice):
    '|'.sequence

re(re_build_lexre):
    choice